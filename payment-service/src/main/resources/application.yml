server:
  port: 8092 # Docker Compose에서 8092:8092로 매핑됨

spring:
  application:
    name: payment-service # 서비스 이름 지정

  datasource:
    url: jdbc:postgresql://localhost:5433/paymentdb # DB 서비스 이름, 기본 포트, DB 이름
    username: paymentuser # Docker Compose env에 설정한 사용자
    password: paymentpass # Docker Compose env에 설정한 비밀번호
    driver-class-name: org.postgresql.Driver

  jpa: # JPA 설정 예시
    hibernate:
      ddl-auto: update # 테스트용. 운영 시에는 migrate 도구 사용 권장
    show-sql: true # 개발/테스트 시 유용
    properties:
      hibernate:
        format_sql: true

  kafka:
    bootstrap-servers: localhost:9092 # Docker Compose의 카프카 서비스 이름과 내부 통신용 포트

  cloud:
    stream:
      kafka:
        binder:
          brokers: ${spring.kafka.bootstrap-servers} # 카프카 바인더도 동일한 주소 사용
          # properties:
          #   configuration:
          #     # 컨슈머 및 프로듀서 공통 속성
      bindings:
        orderCreatedConsumer-in-0: # 입력 바인딩 이름 (임의로 지정)
          destination: order-created # 주문 서비스에서 발행하는 토픽 이름과 동일하게 설정
          group: payment-group # 컨슈머 그룹 이름 (중요: 각 서비스 인스턴스가 메시지를 한 번씩만 처리하도록 그룹 설정)
          consumer:
            configuration:
              auto.offset.reset: earliest
              key.deserializer: org.apache.kafka.common.serialization.StringDeserializer
              value.deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
              spring.json.trusted.packages: com.localy.order_service.order.message.dto # OrderCreatedEvent 패키지 경로 추가
        paymentResultProducer-out-0:
          destination: payment-result # 발행할 카프카 토픽 이름 (주문 서비스의 Input destination과 일치해야 함)
          contentType: application/json # 메시지 컨텐츠 타입 (직렬화 방식과 일치)
          # kafka.producer.properties: # 추가 Kafka 프로듀서 속성
          #   retries: 10 # 발행 실패 시 재시도 횟수

    # === 사용할 함수형 빈 명시적 지정 (결제 서비스의 빈 이름) ===
    function:
      definition: orderCreatedConsumer;paymentResultProducer # <-- 결제 서비스의 빈 이름 지정